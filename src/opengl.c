#include "opengl.h"
#include "debug.h"

#if PLATFORM_WINDOWS
#include "opengl_win32.c"
#else
#error OpenGL platform implementation missing for this OS
#endif

#define DEFINE_GL_FUNCTIONS(type, func) type func = 0;
GL_BINDINGS(DEFINE_GL_FUNCTIONS)
#undef  DEFINE_GL_FUNCTIONS

OpenGL_Context* g_gl_context = 0;

b32 upload_texture2d(Texture2d* t) {
    GLint format = 0;
    switch (t->depth) {
    case 1:
        format = GL_RED;
        break;
    case 3:
        format = GL_RGB;
        break;
    case 4:
        format = GL_RGBA;
        break;
    default:
        invalid_code_path;
        break;
    }

    if (t->id == 0) {
        glGenTextures(1, &t->id);
        glBindTexture(GL_TEXTURE_2D, t->id);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

        glTexImage2D(
            GL_TEXTURE_2D, 
            0, 
            t->depth == 4 ? GL_SRGB_ALPHA : format, 
            t->width, 
            t->height, 
            0, 
            format, 
            GL_UNSIGNED_BYTE, 
            t->pixels
        );
    } else {
        glBindTexture(GL_TEXTURE_2D, t->id);

        glTexSubImage2D(
            GL_TEXTURE_2D, 
            0, 0, 0, 
            t->width, 
            t->height, 
            format, 
            GL_UNSIGNED_BYTE, 
            t->pixels
        );
    }

    return true;
}

b32 init_shader(Shader* shader) {
    GLuint program_id = glCreateProgram();

    GLuint vert_id = glCreateShader(GL_VERTEX_SHADER);
    GLuint frag_id = glCreateShader(GL_FRAGMENT_SHADER);

    GLchar* shader_header = "#version 330 core\n";

    assert(shader->source.data && shader->source.len);

    GLchar* vert_shader[] = { shader_header, "#define VERTEX 1\n", (GLchar*)shader->source.data };
    GLchar* frag_shader[] = { shader_header, "#define FRAGMENT 1\n", (GLchar*)shader->source.data };

    glShaderSource(vert_id, 3, vert_shader, 0);
    glShaderSource(frag_id, 3, frag_shader, 0);

    glCompileShader(vert_id);
    glCompileShader(frag_id);

    glAttachShader(program_id, vert_id);
    glAttachShader(program_id, frag_id);

    glLinkProgram(program_id);
    glValidateProgram(program_id);

    GLint is_linked = 0;
    glGetProgramiv(program_id, GL_LINK_STATUS, &is_linked);
    if (!is_linked) {
        GLsizei ignored;
        char vert_errors[4096];
        char frag_errors[4096];
        char program_errors[4096];

        glGetShaderInfoLog(vert_id, sizeof(vert_errors), &ignored, vert_errors);
        glGetShaderInfoLog(frag_id, sizeof(frag_errors), &ignored, frag_errors);
        glGetProgramInfoLog(program_id, sizeof(program_errors), &ignored, program_errors);

        o_log_error("[OpenGL] Shader compile failed");
        if (vert_errors[0] != 0)
        {
            o_log_error(vert_errors);
        }
        if (frag_errors[0] != 0)
        {
            o_log_error(frag_errors);
        }
        if (program_errors[0] != 0)
        {
            o_log_error(program_errors);
        }
        return false;
    }

    glDeleteShader(vert_id);
    glDeleteShader(frag_id);

    glGetProgramiv(program_id, GL_ACTIVE_UNIFORMS, &shader->uniform_count);
    for (GLint i = 0; i < shader->uniform_count; ++i) {
        GLsizei length;
        GLint size;
        GLenum type;
        GLchar name[SHADER_UNFORM_NAME_CAP];
        glGetActiveUniform(program_id, (GLuint)i, SHADER_UNFORM_NAME_CAP, &length, &size, &type, name);
        Shader_Uniform uniform;
        mem_copy(uniform.name, name, length);
        uniform.name[length] = 0;
        uniform.name_len = (u32)length;
        uniform.type = type;
        uniform.location = glGetUniformLocation(program_id, name);

        shader->uniforms[i] = uniform;
    }

    shader->id = program_id;
    return true;
}

b32 free_shader(Shader* shader) {
    return false; // @TODO
}

static char* get_shader_var_type_string(GLenum type) {
    switch (type) {
        case GL_FLOAT:      return "f32";
        case GL_FLOAT_VEC2: return "Vector2";
        case GL_FLOAT_VEC3: return "Vector3";
        case GL_FLOAT_VEC4: return "Vector4";
        case GL_FLOAT_MAT4: return "Matrix4";
        case GL_SAMPLER_2D: return "Texture2D";
        default:            invalid_code_path;
    }

    return "";
}

static
Shader_Uniform* find_uniform(char* name, GLenum type) {
    Shader* s = get_bound_shader();
    if (!s) {
        o_log_error("[OpenGL] Tried to set uniform but no shader was bound");
        return false;
    }

    for (int i = 0; i < s->uniform_count; ++i) {
        Shader_Uniform* it = &s->uniforms[i];

        if (str_cmp(name, it->name) != 0) continue;

        if (it->type != type) {
            o_log_error("[OpenGL] Tried to set uniform with wrong type. %s has the type of %s", name, get_shader_var_type_string(GL_FLOAT_MAT4));
            return 0;
        }

        return it;
    }

    return 0;
}

b32 set_uniform_m4(char* name, Matrix4 m) {
    Shader_Uniform* var = find_uniform(name, GL_FLOAT_MAT4);
    if (!var) return false; 

    glUniformMatrix4fv(var->location, 1, GL_FALSE, m.e);
    return true;
}

b32 set_uniform_texture(char* name, Texture2d t) {
    Shader_Uniform* var = find_uniform(name, GL_SAMPLER_2D);
    if (!var) return false; 

    glActiveTexture(GL_TEXTURE0 + var->location);
    glBindTexture(GL_TEXTURE_2D, t.id);

    glUniform1i(var->location, var->location);
    return true;
}

b32 set_uniform_v4(char* name, Vector4 v) {
    Shader_Uniform* var = find_uniform(name, GL_FLOAT_VEC4);
    if (!var) return false; 

    glUniform4f(var->location, v.x, v.y, v.z, v.w);
    return true;
}

void set_shader(Shader* s) {
    if (!s) {
        glUseProgram(0);
        g_gl_context->bound_shader = 0;
    } else {
        glUseProgram(s->id);
        g_gl_context->bound_shader = s;
    }
}

Shader* get_bound_shader(void) {
    return g_gl_context->bound_shader;
}

b32 init_framebuffer(int width, int height, int flags, Framebuffer* framebuffer) {
    GLuint handle;
    glGenFramebuffers(1, &handle);
    glBindFramebuffer(GL_FRAMEBUFFER, handle);

    Framebuffer result = { 
        .handle = handle,
        .width  = width,
        .height = height,
        .flags  = flags,
    };

    if ((flags & FF_HDR)) assert((flags & FF_Albedo) == 0);

    if ((flags & FF_Position) != 0) {
        GLuint position_texture;
        glGenTextures(1, &position_texture);
        glBindTexture(GL_TEXTURE_2D, position_texture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, width, height, 0, GL_RGBA, GL_FLOAT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + FCI_Position, GL_TEXTURE_2D, position_texture, 0);
        result.color[FCI_Position] = (Texture2d) {  
            .width  = width, 
            .height = height, 
            .depth  = 4, 
            .id     = position_texture,
        };
    }

    if ((flags & FF_Normal) != 0) {
        GLuint normal_texture;
        glGenTextures(1, &normal_texture);
        glBindTexture(GL_TEXTURE_2D, normal_texture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, width, height, 0, GL_RGBA, GL_FLOAT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + FCI_Normal, GL_TEXTURE_2D, normal_texture, 0);
        result.color[FCI_Normal] = (Texture2d) {  
            .width  = width, 
            .height = height, 
            .depth  = 4, 
            .id     = normal_texture,
        };
    }


    if ((flags & FF_Depth) != 0) {
        GLuint depth_texture;
        glGenTextures(1, &depth_texture);
        glBindTexture(GL_TEXTURE_2D, depth_texture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depth_texture, 0);
        result.depth = (Texture2d) {  
            .width  = width, 
            .height = height, 
            .depth  = 1, 
            .id     = depth_texture,
        };
    }

    if ((flags & FF_Albedo) != 0) {
        GLuint albedo_texture;
        glGenTextures(1, &albedo_texture);
        glBindTexture(GL_TEXTURE_2D, albedo_texture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + FCI_Albedo, GL_TEXTURE_2D, albedo_texture, 0);
        result.color[FCI_Albedo] = (Texture2d) {  
            .width = width, 
            .height = height, 
            .depth = 4, 
            .id = albedo_texture,
        };
    }

    if ((flags & FF_HDR) != 0) {
        GLuint hdr_texture;
        glGenTextures(1, &hdr_texture);
        glBindTexture(GL_TEXTURE_2D, hdr_texture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, width, height, 0, GL_RGBA, GL_FLOAT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + FCI_HDR, GL_TEXTURE_2D, hdr_texture, 0);
        result.color[FCI_HDR] = (Texture2d) {
            .width  = width,
            .height = height,
            .depth  = 4,
            .id     = hdr_texture,
        };
    }

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        // @TODO(colby): do cleanup
        return false;
    }

    *framebuffer = result;

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    return true;
}

b32 free_framebuffer(Framebuffer* framebuffer) {
    int flags = framebuffer->flags;

    GLuint textures_to_delete[FCI_Count + 1] = { 0 }; // + 1 for the depth buffer
    int num_textures_to_delete = 0;

    if ((flags & FF_Position) != 0) textures_to_delete[num_textures_to_delete++] = framebuffer->color[FCI_Position].id;
    if ((flags & FF_Normal) != 0)   textures_to_delete[num_textures_to_delete++] = framebuffer->color[FCI_Normal].id;
    if ((flags & FF_Albedo) != 0)   textures_to_delete[num_textures_to_delete++] = framebuffer->color[FCI_Albedo].id;
    if ((flags & FF_HDR) != 0)      textures_to_delete[num_textures_to_delete++] = framebuffer->color[FCI_HDR].id;
    if ((flags & FF_Depth) != 0)    textures_to_delete[num_textures_to_delete++] = framebuffer->depth.id;

    glDeleteTextures(num_textures_to_delete, textures_to_delete);
    glDeleteFramebuffers(1, &framebuffer->handle);

    *framebuffer = (Framebuffer) { 0 };

    return true;
}

b32 resize_framebuffer(Framebuffer* framebuffer, int width, int height) {
    int flags = framebuffer->flags;
    b32 ok = free_framebuffer(framebuffer);
    ok &= init_framebuffer(width, height, flags, framebuffer);
    return ok;
}

void begin_framebuffer(Framebuffer framebuffer) {
    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer.handle);

    GLuint attachments[FCI_Count] = { 0 };
    int num_attachments = 0;
    
    int flags = framebuffer.flags;
    if ((flags & FF_Position) != 0) attachments[num_attachments++] = GL_COLOR_ATTACHMENT0 + FCI_Position;
    if ((flags & FF_Normal) != 0)   attachments[num_attachments++] = GL_COLOR_ATTACHMENT0 + FCI_Normal;
    if ((flags & FF_Albedo) != 0)   attachments[num_attachments++] = GL_COLOR_ATTACHMENT0 + FCI_Albedo;
    if ((flags & FF_HDR) != 0)      attachments[num_attachments++] = GL_COLOR_ATTACHMENT0 + FCI_HDR;

    glDrawBuffers(num_attachments, attachments);
    glViewport(0, 0, framebuffer.width, framebuffer.height);
}

void end_framebuffer(void) {
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void clear_framebuffer(Vector3 color) {
    glClearColor(color.r, color.g, color.b, 1.f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}